// Code generated by the local DBGEN tool. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"time"

	models "github.com/ArnaudLasnier/pingpong/internal/database/models"
	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/google/uuid"
	"github.com/jaswdr/faker/v2"
	"github.com/stephenafamo/bob"
)

type MatchMod interface {
	Apply(*MatchTemplate)
}

type MatchModFunc func(*MatchTemplate)

func (f MatchModFunc) Apply(n *MatchTemplate) {
	f(n)
}

type MatchModSlice []MatchMod

func (mods MatchModSlice) Apply(n *MatchTemplate) {
	for _, f := range mods {
		f.Apply(n)
	}
}

// MatchTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type MatchTemplate struct {
	ID             func() uuid.UUID
	TournamentID   func() uuid.UUID
	ParentMatch1ID func() null.Val[uuid.UUID]
	ParentMatch2ID func() null.Val[uuid.UUID]
	DueAt          func() time.Time
	Opponent1ID    func() null.Val[uuid.UUID]
	Opponent1Score func() null.Val[int32]
	Opponent2ID    func() null.Val[uuid.UUID]
	Opponent2Score func() null.Val[int32]

	r matchR
	f *Factory
}

type matchR struct {
	Opponent1Player      *matchROpponent1PlayerR
	Opponent2Player      *matchROpponent2PlayerR
	ParentMatch1         *matchRParentMatch1R
	ReverseParentMatch1S []*matchRReverseParentMatch1SR
	ParentMatch2         *matchRParentMatch2R
	ReverseParentMatch2S []*matchRReverseParentMatch2SR
	Tournament           *matchRTournamentR
}

type matchROpponent1PlayerR struct {
	o *PlayerTemplate
}
type matchROpponent2PlayerR struct {
	o *PlayerTemplate
}
type matchRParentMatch1R struct {
	o *MatchTemplate
}
type matchRReverseParentMatch1SR struct {
	number int
	o      *MatchTemplate
}
type matchRParentMatch2R struct {
	o *MatchTemplate
}
type matchRReverseParentMatch2SR struct {
	number int
	o      *MatchTemplate
}
type matchRTournamentR struct {
	o *TournamentTemplate
}

// Apply mods to the MatchTemplate
func (o *MatchTemplate) Apply(mods ...MatchMod) {
	for _, mod := range mods {
		mod.Apply(o)
	}
}

// toModel returns an *models.Match
// this does nothing with the relationship templates
func (o MatchTemplate) toModel() *models.Match {
	m := &models.Match{}

	if o.ID != nil {
		m.ID = o.ID()
	}
	if o.TournamentID != nil {
		m.TournamentID = o.TournamentID()
	}
	if o.ParentMatch1ID != nil {
		m.ParentMatch1ID = o.ParentMatch1ID()
	}
	if o.ParentMatch2ID != nil {
		m.ParentMatch2ID = o.ParentMatch2ID()
	}
	if o.DueAt != nil {
		m.DueAt = o.DueAt()
	}
	if o.Opponent1ID != nil {
		m.Opponent1ID = o.Opponent1ID()
	}
	if o.Opponent1Score != nil {
		m.Opponent1Score = o.Opponent1Score()
	}
	if o.Opponent2ID != nil {
		m.Opponent2ID = o.Opponent2ID()
	}
	if o.Opponent2Score != nil {
		m.Opponent2Score = o.Opponent2Score()
	}

	return m
}

// toModels returns an models.MatchSlice
// this does nothing with the relationship templates
func (o MatchTemplate) toModels(number int) models.MatchSlice {
	m := make(models.MatchSlice, number)

	for i := range m {
		m[i] = o.toModel()
	}

	return m
}

// setModelRels creates and sets the relationships on *models.Match
// according to the relationships in the template. Nothing is inserted into the db
func (t MatchTemplate) setModelRels(o *models.Match) {
	if t.r.Opponent1Player != nil {
		rel := t.r.Opponent1Player.o.toModel()
		rel.R.Opponent1Matches = append(rel.R.Opponent1Matches, o)
		o.Opponent1ID = null.From(rel.ID)
		o.R.Opponent1Player = rel
	}

	if t.r.Opponent2Player != nil {
		rel := t.r.Opponent2Player.o.toModel()
		rel.R.Opponent2Matches = append(rel.R.Opponent2Matches, o)
		o.Opponent2ID = null.From(rel.ID)
		o.R.Opponent2Player = rel
	}

	if t.r.ParentMatch1 != nil {
		rel := t.r.ParentMatch1.o.toModel()
		rel.R.ParentMatch1 = o
		o.ParentMatch1ID = null.From(rel.ID)
		o.R.ParentMatch1 = rel
	}

	if t.r.ReverseParentMatch1S != nil {
		rel := models.MatchSlice{}
		for _, r := range t.r.ReverseParentMatch1S {
			related := r.o.toModels(r.number)
			for _, rel := range related {
				rel.ParentMatch1ID = null.From(o.ID)
				rel.R.ReverseParentMatch1S = append(rel.R.ReverseParentMatch1S, o)
			}
			rel = append(rel, related...)
		}
		o.R.ReverseParentMatch1S = rel
	}

	if t.r.ParentMatch2 != nil {
		rel := t.r.ParentMatch2.o.toModel()
		rel.R.ParentMatch2 = o
		o.ParentMatch2ID = null.From(rel.ID)
		o.R.ParentMatch2 = rel
	}

	if t.r.ReverseParentMatch2S != nil {
		rel := models.MatchSlice{}
		for _, r := range t.r.ReverseParentMatch2S {
			related := r.o.toModels(r.number)
			for _, rel := range related {
				rel.ParentMatch2ID = null.From(o.ID)
				rel.R.ReverseParentMatch2S = append(rel.R.ReverseParentMatch2S, o)
			}
			rel = append(rel, related...)
		}
		o.R.ReverseParentMatch2S = rel
	}

	if t.r.Tournament != nil {
		rel := t.r.Tournament.o.toModel()
		rel.R.Matches = append(rel.R.Matches, o)
		o.TournamentID = rel.ID
		o.R.Tournament = rel
	}
}

// BuildSetter returns an *models.MatchSetter
// this does nothing with the relationship templates
func (o MatchTemplate) BuildSetter() *models.MatchSetter {
	m := &models.MatchSetter{}

	if o.ID != nil {
		m.ID = omit.From(o.ID())
	}
	if o.TournamentID != nil {
		m.TournamentID = omit.From(o.TournamentID())
	}
	if o.ParentMatch1ID != nil {
		m.ParentMatch1ID = omitnull.FromNull(o.ParentMatch1ID())
	}
	if o.ParentMatch2ID != nil {
		m.ParentMatch2ID = omitnull.FromNull(o.ParentMatch2ID())
	}
	if o.DueAt != nil {
		m.DueAt = omit.From(o.DueAt())
	}
	if o.Opponent1ID != nil {
		m.Opponent1ID = omitnull.FromNull(o.Opponent1ID())
	}
	if o.Opponent1Score != nil {
		m.Opponent1Score = omitnull.FromNull(o.Opponent1Score())
	}
	if o.Opponent2ID != nil {
		m.Opponent2ID = omitnull.FromNull(o.Opponent2ID())
	}
	if o.Opponent2Score != nil {
		m.Opponent2Score = omitnull.FromNull(o.Opponent2Score())
	}

	return m
}

// BuildManySetter returns an []*models.MatchSetter
// this does nothing with the relationship templates
func (o MatchTemplate) BuildManySetter(number int) []*models.MatchSetter {
	m := make([]*models.MatchSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.Match
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use MatchTemplate.Create
func (o MatchTemplate) Build() *models.Match {
	m := o.toModel()
	o.setModelRels(m)

	return m
}

// BuildMany returns an models.MatchSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use MatchTemplate.CreateMany
func (o MatchTemplate) BuildMany(number int) models.MatchSlice {
	m := make(models.MatchSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableMatch(m *models.MatchSetter) {
	if m.TournamentID.IsUnset() {
		m.TournamentID = omit.From(random[uuid.UUID](nil))
	}
	if m.DueAt.IsUnset() {
		m.DueAt = omit.From(random[time.Time](nil))
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.Match
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *MatchTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.Match) (context.Context, error) {
	var err error

	if o.r.Opponent1Player != nil {
		var rel0 *models.Player
		ctx, rel0, err = o.r.Opponent1Player.o.create(ctx, exec)
		if err != nil {
			return ctx, err
		}
		err = m.AttachOpponent1Player(ctx, exec, rel0)
		if err != nil {
			return ctx, err
		}
	}

	if o.r.Opponent2Player != nil {
		var rel1 *models.Player
		ctx, rel1, err = o.r.Opponent2Player.o.create(ctx, exec)
		if err != nil {
			return ctx, err
		}
		err = m.AttachOpponent2Player(ctx, exec, rel1)
		if err != nil {
			return ctx, err
		}
	}

	if o.r.ParentMatch1 != nil {
		var rel2 *models.Match
		ctx, rel2, err = o.r.ParentMatch1.o.create(ctx, exec)
		if err != nil {
			return ctx, err
		}
		err = m.AttachParentMatch1(ctx, exec, rel2)
		if err != nil {
			return ctx, err
		}
	}

	if o.r.ReverseParentMatch1S != nil {
		for _, r := range o.r.ReverseParentMatch1S {
			var rel3 models.MatchSlice
			ctx, rel3, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachReverseParentMatch1S(ctx, exec, rel3...)
			if err != nil {
				return ctx, err
			}
		}
	}

	if o.r.ParentMatch2 != nil {
		var rel4 *models.Match
		ctx, rel4, err = o.r.ParentMatch2.o.create(ctx, exec)
		if err != nil {
			return ctx, err
		}
		err = m.AttachParentMatch2(ctx, exec, rel4)
		if err != nil {
			return ctx, err
		}
	}

	if o.r.ReverseParentMatch2S != nil {
		for _, r := range o.r.ReverseParentMatch2S {
			var rel5 models.MatchSlice
			ctx, rel5, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachReverseParentMatch2S(ctx, exec, rel5...)
			if err != nil {
				return ctx, err
			}
		}
	}

	return ctx, err
}

// Create builds a match and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *MatchTemplate) Create(ctx context.Context, exec bob.Executor) (*models.Match, error) {
	_, m, err := o.create(ctx, exec)
	return m, err
}

// create builds a match and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted model
func (o *MatchTemplate) create(ctx context.Context, exec bob.Executor) (context.Context, *models.Match, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableMatch(opt)

	var rel6 *models.Tournament
	if o.r.Tournament == nil {
		var ok bool
		rel6, ok = tournamentCtx.Value(ctx)
		if !ok {
			MatchMods.WithNewTournament().Apply(o)
		}
	}
	if o.r.Tournament != nil {
		ctx, rel6, err = o.r.Tournament.o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}
	opt.TournamentID = omit.From(rel6.ID)

	m, err := models.Matches.Insert(ctx, exec, opt)
	if err != nil {
		return ctx, nil, err
	}
	ctx = matchCtx.WithValue(ctx, m)

	m.R.Tournament = rel6

	ctx, err = o.insertOptRels(ctx, exec, m)
	return ctx, m, err
}

// CreateMany builds multiple matches and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o MatchTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.MatchSlice, error) {
	_, m, err := o.createMany(ctx, exec, number)
	return m, err
}

// createMany builds multiple matches and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted models
func (o MatchTemplate) createMany(ctx context.Context, exec bob.Executor, number int) (context.Context, models.MatchSlice, error) {
	var err error
	m := make(models.MatchSlice, number)

	for i := range m {
		ctx, m[i], err = o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	return ctx, m, nil
}

// Match has methods that act as mods for the MatchTemplate
var MatchMods matchMods

type matchMods struct{}

func (m matchMods) RandomizeAllColumns(f *faker.Faker) MatchMod {
	return MatchModSlice{
		MatchMods.RandomID(f),
		MatchMods.RandomTournamentID(f),
		MatchMods.RandomParentMatch1ID(f),
		MatchMods.RandomParentMatch2ID(f),
		MatchMods.RandomDueAt(f),
		MatchMods.RandomOpponent1ID(f),
		MatchMods.RandomOpponent1Score(f),
		MatchMods.RandomOpponent2ID(f),
		MatchMods.RandomOpponent2Score(f),
	}
}

// Set the model columns to this value
func (m matchMods) ID(val uuid.UUID) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ID = func() uuid.UUID { return val }
	})
}

// Set the Column from the function
func (m matchMods) IDFunc(f func() uuid.UUID) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ID = f
	})
}

// Clear any values for the column
func (m matchMods) UnsetID() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m matchMods) RandomID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ID = func() uuid.UUID {
			return random[uuid.UUID](f)
		}
	})
}

func (m matchMods) ensureID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		if o.ID != nil {
			return
		}

		o.ID = func() uuid.UUID {
			return random[uuid.UUID](f)
		}
	})
}

// Set the model columns to this value
func (m matchMods) TournamentID(val uuid.UUID) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.TournamentID = func() uuid.UUID { return val }
	})
}

// Set the Column from the function
func (m matchMods) TournamentIDFunc(f func() uuid.UUID) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.TournamentID = f
	})
}

// Clear any values for the column
func (m matchMods) UnsetTournamentID() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.TournamentID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m matchMods) RandomTournamentID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.TournamentID = func() uuid.UUID {
			return random[uuid.UUID](f)
		}
	})
}

func (m matchMods) ensureTournamentID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		if o.TournamentID != nil {
			return
		}

		o.TournamentID = func() uuid.UUID {
			return random[uuid.UUID](f)
		}
	})
}

// Set the model columns to this value
func (m matchMods) ParentMatch1ID(val null.Val[uuid.UUID]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ParentMatch1ID = func() null.Val[uuid.UUID] { return val }
	})
}

// Set the Column from the function
func (m matchMods) ParentMatch1IDFunc(f func() null.Val[uuid.UUID]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ParentMatch1ID = f
	})
}

// Clear any values for the column
func (m matchMods) UnsetParentMatch1ID() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ParentMatch1ID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m matchMods) RandomParentMatch1ID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ParentMatch1ID = func() null.Val[uuid.UUID] {
			return randomNull[uuid.UUID](f)
		}
	})
}

func (m matchMods) ensureParentMatch1ID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		if o.ParentMatch1ID != nil {
			return
		}

		o.ParentMatch1ID = func() null.Val[uuid.UUID] {
			return randomNull[uuid.UUID](f)
		}
	})
}

// Set the model columns to this value
func (m matchMods) ParentMatch2ID(val null.Val[uuid.UUID]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ParentMatch2ID = func() null.Val[uuid.UUID] { return val }
	})
}

// Set the Column from the function
func (m matchMods) ParentMatch2IDFunc(f func() null.Val[uuid.UUID]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ParentMatch2ID = f
	})
}

// Clear any values for the column
func (m matchMods) UnsetParentMatch2ID() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ParentMatch2ID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m matchMods) RandomParentMatch2ID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.ParentMatch2ID = func() null.Val[uuid.UUID] {
			return randomNull[uuid.UUID](f)
		}
	})
}

func (m matchMods) ensureParentMatch2ID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		if o.ParentMatch2ID != nil {
			return
		}

		o.ParentMatch2ID = func() null.Val[uuid.UUID] {
			return randomNull[uuid.UUID](f)
		}
	})
}

// Set the model columns to this value
func (m matchMods) DueAt(val time.Time) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.DueAt = func() time.Time { return val }
	})
}

// Set the Column from the function
func (m matchMods) DueAtFunc(f func() time.Time) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.DueAt = f
	})
}

// Clear any values for the column
func (m matchMods) UnsetDueAt() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.DueAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m matchMods) RandomDueAt(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.DueAt = func() time.Time {
			return random[time.Time](f)
		}
	})
}

func (m matchMods) ensureDueAt(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		if o.DueAt != nil {
			return
		}

		o.DueAt = func() time.Time {
			return random[time.Time](f)
		}
	})
}

// Set the model columns to this value
func (m matchMods) Opponent1ID(val null.Val[uuid.UUID]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent1ID = func() null.Val[uuid.UUID] { return val }
	})
}

// Set the Column from the function
func (m matchMods) Opponent1IDFunc(f func() null.Val[uuid.UUID]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent1ID = f
	})
}

// Clear any values for the column
func (m matchMods) UnsetOpponent1ID() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent1ID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m matchMods) RandomOpponent1ID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent1ID = func() null.Val[uuid.UUID] {
			return randomNull[uuid.UUID](f)
		}
	})
}

func (m matchMods) ensureOpponent1ID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		if o.Opponent1ID != nil {
			return
		}

		o.Opponent1ID = func() null.Val[uuid.UUID] {
			return randomNull[uuid.UUID](f)
		}
	})
}

// Set the model columns to this value
func (m matchMods) Opponent1Score(val null.Val[int32]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent1Score = func() null.Val[int32] { return val }
	})
}

// Set the Column from the function
func (m matchMods) Opponent1ScoreFunc(f func() null.Val[int32]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent1Score = f
	})
}

// Clear any values for the column
func (m matchMods) UnsetOpponent1Score() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent1Score = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m matchMods) RandomOpponent1Score(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent1Score = func() null.Val[int32] {
			return randomNull[int32](f)
		}
	})
}

func (m matchMods) ensureOpponent1Score(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		if o.Opponent1Score != nil {
			return
		}

		o.Opponent1Score = func() null.Val[int32] {
			return randomNull[int32](f)
		}
	})
}

// Set the model columns to this value
func (m matchMods) Opponent2ID(val null.Val[uuid.UUID]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent2ID = func() null.Val[uuid.UUID] { return val }
	})
}

// Set the Column from the function
func (m matchMods) Opponent2IDFunc(f func() null.Val[uuid.UUID]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent2ID = f
	})
}

// Clear any values for the column
func (m matchMods) UnsetOpponent2ID() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent2ID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m matchMods) RandomOpponent2ID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent2ID = func() null.Val[uuid.UUID] {
			return randomNull[uuid.UUID](f)
		}
	})
}

func (m matchMods) ensureOpponent2ID(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		if o.Opponent2ID != nil {
			return
		}

		o.Opponent2ID = func() null.Val[uuid.UUID] {
			return randomNull[uuid.UUID](f)
		}
	})
}

// Set the model columns to this value
func (m matchMods) Opponent2Score(val null.Val[int32]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent2Score = func() null.Val[int32] { return val }
	})
}

// Set the Column from the function
func (m matchMods) Opponent2ScoreFunc(f func() null.Val[int32]) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent2Score = f
	})
}

// Clear any values for the column
func (m matchMods) UnsetOpponent2Score() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent2Score = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m matchMods) RandomOpponent2Score(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.Opponent2Score = func() null.Val[int32] {
			return randomNull[int32](f)
		}
	})
}

func (m matchMods) ensureOpponent2Score(f *faker.Faker) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		if o.Opponent2Score != nil {
			return
		}

		o.Opponent2Score = func() null.Val[int32] {
			return randomNull[int32](f)
		}
	})
}

func (m matchMods) WithOpponent1Player(rel *PlayerTemplate) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.Opponent1Player = &matchROpponent1PlayerR{
			o: rel,
		}
	})
}

func (m matchMods) WithNewOpponent1Player(mods ...PlayerMod) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		related := o.f.NewPlayer(mods...)

		m.WithOpponent1Player(related).Apply(o)
	})
}

func (m matchMods) WithoutOpponent1Player() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.Opponent1Player = nil
	})
}

func (m matchMods) WithOpponent2Player(rel *PlayerTemplate) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.Opponent2Player = &matchROpponent2PlayerR{
			o: rel,
		}
	})
}

func (m matchMods) WithNewOpponent2Player(mods ...PlayerMod) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		related := o.f.NewPlayer(mods...)

		m.WithOpponent2Player(related).Apply(o)
	})
}

func (m matchMods) WithoutOpponent2Player() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.Opponent2Player = nil
	})
}

func (m matchMods) WithParentMatch1(rel *MatchTemplate) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.ParentMatch1 = &matchRParentMatch1R{
			o: rel,
		}
	})
}

func (m matchMods) WithNewParentMatch1(mods ...MatchMod) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		related := o.f.NewMatch(mods...)

		m.WithParentMatch1(related).Apply(o)
	})
}

func (m matchMods) WithoutParentMatch1() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.ParentMatch1 = nil
	})
}

func (m matchMods) WithParentMatch2(rel *MatchTemplate) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.ParentMatch2 = &matchRParentMatch2R{
			o: rel,
		}
	})
}

func (m matchMods) WithNewParentMatch2(mods ...MatchMod) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		related := o.f.NewMatch(mods...)

		m.WithParentMatch2(related).Apply(o)
	})
}

func (m matchMods) WithoutParentMatch2() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.ParentMatch2 = nil
	})
}

func (m matchMods) WithTournament(rel *TournamentTemplate) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.Tournament = &matchRTournamentR{
			o: rel,
		}
	})
}

func (m matchMods) WithNewTournament(mods ...TournamentMod) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		related := o.f.NewTournament(mods...)

		m.WithTournament(related).Apply(o)
	})
}

func (m matchMods) WithoutTournament() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.Tournament = nil
	})
}

func (m matchMods) WithReverseParentMatch1S(number int, related *MatchTemplate) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.ReverseParentMatch1S = []*matchRReverseParentMatch1SR{{
			number: number,
			o:      related,
		}}
	})
}

func (m matchMods) WithNewReverseParentMatch1S(number int, mods ...MatchMod) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		related := o.f.NewMatch(mods...)
		m.WithReverseParentMatch1S(number, related).Apply(o)
	})
}

func (m matchMods) AddReverseParentMatch1S(number int, related *MatchTemplate) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.ReverseParentMatch1S = append(o.r.ReverseParentMatch1S, &matchRReverseParentMatch1SR{
			number: number,
			o:      related,
		})
	})
}

func (m matchMods) AddNewReverseParentMatch1S(number int, mods ...MatchMod) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		related := o.f.NewMatch(mods...)
		m.AddReverseParentMatch1S(number, related).Apply(o)
	})
}

func (m matchMods) WithoutReverseParentMatch1S() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.ReverseParentMatch1S = nil
	})
}

func (m matchMods) WithReverseParentMatch2S(number int, related *MatchTemplate) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.ReverseParentMatch2S = []*matchRReverseParentMatch2SR{{
			number: number,
			o:      related,
		}}
	})
}

func (m matchMods) WithNewReverseParentMatch2S(number int, mods ...MatchMod) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		related := o.f.NewMatch(mods...)
		m.WithReverseParentMatch2S(number, related).Apply(o)
	})
}

func (m matchMods) AddReverseParentMatch2S(number int, related *MatchTemplate) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.ReverseParentMatch2S = append(o.r.ReverseParentMatch2S, &matchRReverseParentMatch2SR{
			number: number,
			o:      related,
		})
	})
}

func (m matchMods) AddNewReverseParentMatch2S(number int, mods ...MatchMod) MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		related := o.f.NewMatch(mods...)
		m.AddReverseParentMatch2S(number, related).Apply(o)
	})
}

func (m matchMods) WithoutReverseParentMatch2S() MatchMod {
	return MatchModFunc(func(o *MatchTemplate) {
		o.r.ReverseParentMatch2S = nil
	})
}
