// Code generated by BobGen psql v0.25.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"

	models "github.com/ArnaudLasnier/pingpong/internal/tournament/database/models"
	"github.com/aarondl/opt/omit"
	"github.com/google/uuid"
	"github.com/jaswdr/faker/v2"
	"github.com/stephenafamo/bob"
)

type TournamentParticipationMod interface {
	Apply(*TournamentParticipationTemplate)
}

type TournamentParticipationModFunc func(*TournamentParticipationTemplate)

func (f TournamentParticipationModFunc) Apply(n *TournamentParticipationTemplate) {
	f(n)
}

type TournamentParticipationModSlice []TournamentParticipationMod

func (mods TournamentParticipationModSlice) Apply(n *TournamentParticipationTemplate) {
	for _, f := range mods {
		f.Apply(n)
	}
}

// TournamentParticipationTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type TournamentParticipationTemplate struct {
	TournamentID  func() uuid.UUID
	ParticipantID func() uuid.UUID

	r tournamentParticipationR
	f *Factory
}

type tournamentParticipationR struct {
	ParticipantPlayer *tournamentParticipationRParticipantPlayerR
	Tournament        *tournamentParticipationRTournamentR
}

type tournamentParticipationRParticipantPlayerR struct {
	o *PlayerTemplate
}
type tournamentParticipationRTournamentR struct {
	o *TournamentTemplate
}

// Apply mods to the TournamentParticipationTemplate
func (o *TournamentParticipationTemplate) Apply(mods ...TournamentParticipationMod) {
	for _, mod := range mods {
		mod.Apply(o)
	}
}

// toModel returns an *models.TournamentParticipation
// this does nothing with the relationship templates
func (o TournamentParticipationTemplate) toModel() *models.TournamentParticipation {
	m := &models.TournamentParticipation{}

	if o.TournamentID != nil {
		m.TournamentID = o.TournamentID()
	}
	if o.ParticipantID != nil {
		m.ParticipantID = o.ParticipantID()
	}

	return m
}

// toModels returns an models.TournamentParticipationSlice
// this does nothing with the relationship templates
func (o TournamentParticipationTemplate) toModels(number int) models.TournamentParticipationSlice {
	m := make(models.TournamentParticipationSlice, number)

	for i := range m {
		m[i] = o.toModel()
	}

	return m
}

// setModelRels creates and sets the relationships on *models.TournamentParticipation
// according to the relationships in the template. Nothing is inserted into the db
func (t TournamentParticipationTemplate) setModelRels(o *models.TournamentParticipation) {
	if t.r.ParticipantPlayer != nil {
		rel := t.r.ParticipantPlayer.o.toModel()
		o.ParticipantID = rel.ID
		o.R.ParticipantPlayer = rel
	}

	if t.r.Tournament != nil {
		rel := t.r.Tournament.o.toModel()
		o.TournamentID = rel.ID
		o.R.Tournament = rel
	}
}

// BuildSetter returns an *models.TournamentParticipationSetter
// this does nothing with the relationship templates
func (o TournamentParticipationTemplate) BuildSetter() *models.TournamentParticipationSetter {
	m := &models.TournamentParticipationSetter{}

	if o.TournamentID != nil {
		m.TournamentID = omit.From(o.TournamentID())
	}
	if o.ParticipantID != nil {
		m.ParticipantID = omit.From(o.ParticipantID())
	}

	return m
}

// BuildManySetter returns an []*models.TournamentParticipationSetter
// this does nothing with the relationship templates
func (o TournamentParticipationTemplate) BuildManySetter(number int) []*models.TournamentParticipationSetter {
	m := make([]*models.TournamentParticipationSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.TournamentParticipation
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use TournamentParticipationTemplate.Create
func (o TournamentParticipationTemplate) Build() *models.TournamentParticipation {
	m := o.toModel()
	o.setModelRels(m)

	return m
}

// BuildMany returns an models.TournamentParticipationSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use TournamentParticipationTemplate.CreateMany
func (o TournamentParticipationTemplate) BuildMany(number int) models.TournamentParticipationSlice {
	m := make(models.TournamentParticipationSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableTournamentParticipation(m *models.TournamentParticipationSetter) {
	if m.TournamentID.IsUnset() {
		m.TournamentID = omit.From(random[uuid.UUID](nil))
	}
	if m.ParticipantID.IsUnset() {
		m.ParticipantID = omit.From(random[uuid.UUID](nil))
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.TournamentParticipation
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *TournamentParticipationTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.TournamentParticipation) (context.Context, error) {
	var err error

	return ctx, err
}

// Create builds a tournamentParticipation and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *TournamentParticipationTemplate) Create(ctx context.Context, exec bob.Executor) (*models.TournamentParticipation, error) {
	_, m, err := o.create(ctx, exec)
	return m, err
}

// create builds a tournamentParticipation and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted model
func (o *TournamentParticipationTemplate) create(ctx context.Context, exec bob.Executor) (context.Context, *models.TournamentParticipation, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableTournamentParticipation(opt)

	var rel0 *models.Player
	if o.r.ParticipantPlayer == nil {
		var ok bool
		rel0, ok = playerCtx.Value(ctx)
		if !ok {
			TournamentParticipationMods.WithNewParticipantPlayer().Apply(o)
		}
	}
	if o.r.ParticipantPlayer != nil {
		ctx, rel0, err = o.r.ParticipantPlayer.o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}
	opt.ParticipantID = omit.From(rel0.ID)

	var rel1 *models.Tournament
	if o.r.Tournament == nil {
		var ok bool
		rel1, ok = tournamentCtx.Value(ctx)
		if !ok {
			TournamentParticipationMods.WithNewTournament().Apply(o)
		}
	}
	if o.r.Tournament != nil {
		ctx, rel1, err = o.r.Tournament.o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}
	opt.TournamentID = omit.From(rel1.ID)

	m, err := models.TournamentParticipations.Insert(ctx, exec, opt)
	if err != nil {
		return ctx, nil, err
	}
	ctx = tournamentParticipationCtx.WithValue(ctx, m)

	m.R.ParticipantPlayer = rel0
	m.R.Tournament = rel1

	ctx, err = o.insertOptRels(ctx, exec, m)
	return ctx, m, err
}

// CreateMany builds multiple tournamentParticipations and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o TournamentParticipationTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.TournamentParticipationSlice, error) {
	_, m, err := o.createMany(ctx, exec, number)
	return m, err
}

// createMany builds multiple tournamentParticipations and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted models
func (o TournamentParticipationTemplate) createMany(ctx context.Context, exec bob.Executor, number int) (context.Context, models.TournamentParticipationSlice, error) {
	var err error
	m := make(models.TournamentParticipationSlice, number)

	for i := range m {
		ctx, m[i], err = o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	return ctx, m, nil
}

// TournamentParticipation has methods that act as mods for the TournamentParticipationTemplate
var TournamentParticipationMods tournamentParticipationMods

type tournamentParticipationMods struct{}

func (m tournamentParticipationMods) RandomizeAllColumns(f *faker.Faker) TournamentParticipationMod {
	return TournamentParticipationModSlice{
		TournamentParticipationMods.RandomTournamentID(f),
		TournamentParticipationMods.RandomParticipantID(f),
	}
}

// Set the model columns to this value
func (m tournamentParticipationMods) TournamentID(val uuid.UUID) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.TournamentID = func() uuid.UUID { return val }
	})
}

// Set the Column from the function
func (m tournamentParticipationMods) TournamentIDFunc(f func() uuid.UUID) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.TournamentID = f
	})
}

// Clear any values for the column
func (m tournamentParticipationMods) UnsetTournamentID() TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.TournamentID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m tournamentParticipationMods) RandomTournamentID(f *faker.Faker) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.TournamentID = func() uuid.UUID {
			return random[uuid.UUID](f)
		}
	})
}

func (m tournamentParticipationMods) ensureTournamentID(f *faker.Faker) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		if o.TournamentID != nil {
			return
		}

		o.TournamentID = func() uuid.UUID {
			return random[uuid.UUID](f)
		}
	})
}

// Set the model columns to this value
func (m tournamentParticipationMods) ParticipantID(val uuid.UUID) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.ParticipantID = func() uuid.UUID { return val }
	})
}

// Set the Column from the function
func (m tournamentParticipationMods) ParticipantIDFunc(f func() uuid.UUID) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.ParticipantID = f
	})
}

// Clear any values for the column
func (m tournamentParticipationMods) UnsetParticipantID() TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.ParticipantID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m tournamentParticipationMods) RandomParticipantID(f *faker.Faker) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.ParticipantID = func() uuid.UUID {
			return random[uuid.UUID](f)
		}
	})
}

func (m tournamentParticipationMods) ensureParticipantID(f *faker.Faker) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		if o.ParticipantID != nil {
			return
		}

		o.ParticipantID = func() uuid.UUID {
			return random[uuid.UUID](f)
		}
	})
}

func (m tournamentParticipationMods) WithParticipantPlayer(rel *PlayerTemplate) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.r.ParticipantPlayer = &tournamentParticipationRParticipantPlayerR{
			o: rel,
		}
	})
}

func (m tournamentParticipationMods) WithNewParticipantPlayer(mods ...PlayerMod) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		related := o.f.NewPlayer(mods...)

		m.WithParticipantPlayer(related).Apply(o)
	})
}

func (m tournamentParticipationMods) WithoutParticipantPlayer() TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.r.ParticipantPlayer = nil
	})
}

func (m tournamentParticipationMods) WithTournament(rel *TournamentTemplate) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.r.Tournament = &tournamentParticipationRTournamentR{
			o: rel,
		}
	})
}

func (m tournamentParticipationMods) WithNewTournament(mods ...TournamentMod) TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		related := o.f.NewTournament(mods...)

		m.WithTournament(related).Apply(o)
	})
}

func (m tournamentParticipationMods) WithoutTournament() TournamentParticipationMod {
	return TournamentParticipationModFunc(func(o *TournamentParticipationTemplate) {
		o.r.Tournament = nil
	})
}
