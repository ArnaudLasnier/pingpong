// Code generated by BobGen psql v0.25.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/google/uuid"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/im"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
)

// Match is an object representing the database table.
type Match struct {
	ID             uuid.UUID           `db:"id,pk" `
	TournamentID   uuid.UUID           `db:"tournament_id" `
	ParentMatch1ID null.Val[uuid.UUID] `db:"parent_match_1_id" `
	ParentMatch2ID null.Val[uuid.UUID] `db:"parent_match_2_id" `
	DueAt          time.Time           `db:"due_at" `
	Opponent1ID    null.Val[uuid.UUID] `db:"opponent_1_id" `
	Opponent1Score null.Val[int32]     `db:"opponent_1_score" `
	Opponent2ID    null.Val[uuid.UUID] `db:"opponent_2_id" `
	Opponent2Score null.Val[int32]     `db:"opponent_2_score" `

	R matchR `db:"-" `
}

// MatchSlice is an alias for a slice of pointers to Match.
// This should almost always be used instead of []*Match.
type MatchSlice []*Match

// Matches contains methods to work with the match table
var Matches = psql.NewTablex[*Match, MatchSlice, *MatchSetter]("", "match")

// MatchesQuery is a query on the match table
type MatchesQuery = *psql.ViewQuery[*Match, MatchSlice]

// MatchesStmt is a prepared statment on match
type MatchesStmt = bob.QueryStmt[*Match, MatchSlice]

// matchR is where relationships are stored.
type matchR struct {
	Opponent1Player      *Player     // match.match_opponent_1_id_fkey
	Opponent2Player      *Player     // match.match_opponent_2_id_fkey
	ParentMatch1         *Match      // match.match_parent_match_1_id_fkey
	ReverseParentMatch1S MatchSlice  // match.match_parent_match_1_id_fkey__self_join_reverse
	ParentMatch2         *Match      // match.match_parent_match_2_id_fkey
	ReverseParentMatch2S MatchSlice  // match.match_parent_match_2_id_fkey__self_join_reverse
	Tournament           *Tournament // match.match_tournament_id_fkey
}

// MatchSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type MatchSetter struct {
	ID             omit.Val[uuid.UUID]     `db:"id,pk"`
	TournamentID   omit.Val[uuid.UUID]     `db:"tournament_id"`
	ParentMatch1ID omitnull.Val[uuid.UUID] `db:"parent_match_1_id"`
	ParentMatch2ID omitnull.Val[uuid.UUID] `db:"parent_match_2_id"`
	DueAt          omit.Val[time.Time]     `db:"due_at"`
	Opponent1ID    omitnull.Val[uuid.UUID] `db:"opponent_1_id"`
	Opponent1Score omitnull.Val[int32]     `db:"opponent_1_score"`
	Opponent2ID    omitnull.Val[uuid.UUID] `db:"opponent_2_id"`
	Opponent2Score omitnull.Val[int32]     `db:"opponent_2_score"`
}

func (s MatchSetter) SetColumns() []string {
	vals := make([]string, 0, 9)
	if !s.ID.IsUnset() {
		vals = append(vals, "id")
	}

	if !s.TournamentID.IsUnset() {
		vals = append(vals, "tournament_id")
	}

	if !s.ParentMatch1ID.IsUnset() {
		vals = append(vals, "parent_match_1_id")
	}

	if !s.ParentMatch2ID.IsUnset() {
		vals = append(vals, "parent_match_2_id")
	}

	if !s.DueAt.IsUnset() {
		vals = append(vals, "due_at")
	}

	if !s.Opponent1ID.IsUnset() {
		vals = append(vals, "opponent_1_id")
	}

	if !s.Opponent1Score.IsUnset() {
		vals = append(vals, "opponent_1_score")
	}

	if !s.Opponent2ID.IsUnset() {
		vals = append(vals, "opponent_2_id")
	}

	if !s.Opponent2Score.IsUnset() {
		vals = append(vals, "opponent_2_score")
	}

	return vals
}

func (s MatchSetter) Overwrite(t *Match) {
	if !s.ID.IsUnset() {
		t.ID, _ = s.ID.Get()
	}
	if !s.TournamentID.IsUnset() {
		t.TournamentID, _ = s.TournamentID.Get()
	}
	if !s.ParentMatch1ID.IsUnset() {
		t.ParentMatch1ID, _ = s.ParentMatch1ID.GetNull()
	}
	if !s.ParentMatch2ID.IsUnset() {
		t.ParentMatch2ID, _ = s.ParentMatch2ID.GetNull()
	}
	if !s.DueAt.IsUnset() {
		t.DueAt, _ = s.DueAt.Get()
	}
	if !s.Opponent1ID.IsUnset() {
		t.Opponent1ID, _ = s.Opponent1ID.GetNull()
	}
	if !s.Opponent1Score.IsUnset() {
		t.Opponent1Score, _ = s.Opponent1Score.GetNull()
	}
	if !s.Opponent2ID.IsUnset() {
		t.Opponent2ID, _ = s.Opponent2ID.GetNull()
	}
	if !s.Opponent2Score.IsUnset() {
		t.Opponent2Score, _ = s.Opponent2Score.GetNull()
	}
}

func (s MatchSetter) InsertMod() bob.Mod[*dialect.InsertQuery] {
	vals := make([]bob.Expression, 9)
	if s.ID.IsUnset() {
		vals[0] = psql.Raw("DEFAULT")
	} else {
		vals[0] = psql.Arg(s.ID)
	}

	if s.TournamentID.IsUnset() {
		vals[1] = psql.Raw("DEFAULT")
	} else {
		vals[1] = psql.Arg(s.TournamentID)
	}

	if s.ParentMatch1ID.IsUnset() {
		vals[2] = psql.Raw("DEFAULT")
	} else {
		vals[2] = psql.Arg(s.ParentMatch1ID)
	}

	if s.ParentMatch2ID.IsUnset() {
		vals[3] = psql.Raw("DEFAULT")
	} else {
		vals[3] = psql.Arg(s.ParentMatch2ID)
	}

	if s.DueAt.IsUnset() {
		vals[4] = psql.Raw("DEFAULT")
	} else {
		vals[4] = psql.Arg(s.DueAt)
	}

	if s.Opponent1ID.IsUnset() {
		vals[5] = psql.Raw("DEFAULT")
	} else {
		vals[5] = psql.Arg(s.Opponent1ID)
	}

	if s.Opponent1Score.IsUnset() {
		vals[6] = psql.Raw("DEFAULT")
	} else {
		vals[6] = psql.Arg(s.Opponent1Score)
	}

	if s.Opponent2ID.IsUnset() {
		vals[7] = psql.Raw("DEFAULT")
	} else {
		vals[7] = psql.Arg(s.Opponent2ID)
	}

	if s.Opponent2Score.IsUnset() {
		vals[8] = psql.Raw("DEFAULT")
	} else {
		vals[8] = psql.Arg(s.Opponent2Score)
	}

	return im.Values(vals...)
}

func (s MatchSetter) Apply(q *dialect.UpdateQuery) {
	um.Set(s.Expressions()...).Apply(q)
}

func (s MatchSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 9)

	if !s.ID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if !s.TournamentID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "tournament_id")...),
			psql.Arg(s.TournamentID),
		}})
	}

	if !s.ParentMatch1ID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "parent_match_1_id")...),
			psql.Arg(s.ParentMatch1ID),
		}})
	}

	if !s.ParentMatch2ID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "parent_match_2_id")...),
			psql.Arg(s.ParentMatch2ID),
		}})
	}

	if !s.DueAt.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "due_at")...),
			psql.Arg(s.DueAt),
		}})
	}

	if !s.Opponent1ID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "opponent_1_id")...),
			psql.Arg(s.Opponent1ID),
		}})
	}

	if !s.Opponent1Score.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "opponent_1_score")...),
			psql.Arg(s.Opponent1Score),
		}})
	}

	if !s.Opponent2ID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "opponent_2_id")...),
			psql.Arg(s.Opponent2ID),
		}})
	}

	if !s.Opponent2Score.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "opponent_2_score")...),
			psql.Arg(s.Opponent2Score),
		}})
	}

	return exprs
}

type matchColumnNames struct {
	ID             string
	TournamentID   string
	ParentMatch1ID string
	ParentMatch2ID string
	DueAt          string
	Opponent1ID    string
	Opponent1Score string
	Opponent2ID    string
	Opponent2Score string
}

type matchRelationshipJoins[Q dialect.Joinable] struct {
	Opponent1Player      bob.Mod[Q]
	Opponent2Player      bob.Mod[Q]
	ParentMatch1         bob.Mod[Q]
	ReverseParentMatch1S bob.Mod[Q]
	ParentMatch2         bob.Mod[Q]
	ReverseParentMatch2S bob.Mod[Q]
	Tournament           bob.Mod[Q]
}

func buildMatchRelationshipJoins[Q dialect.Joinable](ctx context.Context, typ string) matchRelationshipJoins[Q] {
	return matchRelationshipJoins[Q]{
		Opponent1Player:      matchesJoinOpponent1Player[Q](ctx, typ),
		Opponent2Player:      matchesJoinOpponent2Player[Q](ctx, typ),
		ParentMatch1:         matchesJoinParentMatch1[Q](ctx, typ),
		ReverseParentMatch1S: matchesJoinReverseParentMatch1S[Q](ctx, typ),
		ParentMatch2:         matchesJoinParentMatch2[Q](ctx, typ),
		ReverseParentMatch2S: matchesJoinReverseParentMatch2S[Q](ctx, typ),
		Tournament:           matchesJoinTournament[Q](ctx, typ),
	}
}

func matchesJoin[Q dialect.Joinable](ctx context.Context) joinSet[matchRelationshipJoins[Q]] {
	return joinSet[matchRelationshipJoins[Q]]{
		InnerJoin: buildMatchRelationshipJoins[Q](ctx, clause.InnerJoin),
		LeftJoin:  buildMatchRelationshipJoins[Q](ctx, clause.LeftJoin),
		RightJoin: buildMatchRelationshipJoins[Q](ctx, clause.RightJoin),
	}
}

var MatchColumns = struct {
	ID             psql.Expression
	TournamentID   psql.Expression
	ParentMatch1ID psql.Expression
	ParentMatch2ID psql.Expression
	DueAt          psql.Expression
	Opponent1ID    psql.Expression
	Opponent1Score psql.Expression
	Opponent2ID    psql.Expression
	Opponent2Score psql.Expression
}{
	ID:             psql.Quote("match", "id"),
	TournamentID:   psql.Quote("match", "tournament_id"),
	ParentMatch1ID: psql.Quote("match", "parent_match_1_id"),
	ParentMatch2ID: psql.Quote("match", "parent_match_2_id"),
	DueAt:          psql.Quote("match", "due_at"),
	Opponent1ID:    psql.Quote("match", "opponent_1_id"),
	Opponent1Score: psql.Quote("match", "opponent_1_score"),
	Opponent2ID:    psql.Quote("match", "opponent_2_id"),
	Opponent2Score: psql.Quote("match", "opponent_2_score"),
}

type matchWhere[Q psql.Filterable] struct {
	ID             psql.WhereMod[Q, uuid.UUID]
	TournamentID   psql.WhereMod[Q, uuid.UUID]
	ParentMatch1ID psql.WhereNullMod[Q, uuid.UUID]
	ParentMatch2ID psql.WhereNullMod[Q, uuid.UUID]
	DueAt          psql.WhereMod[Q, time.Time]
	Opponent1ID    psql.WhereNullMod[Q, uuid.UUID]
	Opponent1Score psql.WhereNullMod[Q, int32]
	Opponent2ID    psql.WhereNullMod[Q, uuid.UUID]
	Opponent2Score psql.WhereNullMod[Q, int32]
}

func MatchWhere[Q psql.Filterable]() matchWhere[Q] {
	return matchWhere[Q]{
		ID:             psql.Where[Q, uuid.UUID](MatchColumns.ID),
		TournamentID:   psql.Where[Q, uuid.UUID](MatchColumns.TournamentID),
		ParentMatch1ID: psql.WhereNull[Q, uuid.UUID](MatchColumns.ParentMatch1ID),
		ParentMatch2ID: psql.WhereNull[Q, uuid.UUID](MatchColumns.ParentMatch2ID),
		DueAt:          psql.Where[Q, time.Time](MatchColumns.DueAt),
		Opponent1ID:    psql.WhereNull[Q, uuid.UUID](MatchColumns.Opponent1ID),
		Opponent1Score: psql.WhereNull[Q, int32](MatchColumns.Opponent1Score),
		Opponent2ID:    psql.WhereNull[Q, uuid.UUID](MatchColumns.Opponent2ID),
		Opponent2Score: psql.WhereNull[Q, int32](MatchColumns.Opponent2Score),
	}
}

// FindMatch retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindMatch(ctx context.Context, exec bob.Executor, IDPK uuid.UUID, cols ...string) (*Match, error) {
	if len(cols) == 0 {
		return Matches.Query(
			ctx, exec,
			SelectWhere.Matches.ID.EQ(IDPK),
		).One()
	}

	return Matches.Query(
		ctx, exec,
		SelectWhere.Matches.ID.EQ(IDPK),
		sm.Columns(Matches.Columns().Only(cols...)),
	).One()
}

// MatchExists checks the presence of a single record by primary key
func MatchExists(ctx context.Context, exec bob.Executor, IDPK uuid.UUID) (bool, error) {
	return Matches.Query(
		ctx, exec,
		SelectWhere.Matches.ID.EQ(IDPK),
	).Exists()
}

// PrimaryKeyVals returns the primary key values of the Match
func (o *Match) PrimaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

// Update uses an executor to update the Match
func (o *Match) Update(ctx context.Context, exec bob.Executor, s *MatchSetter) error {
	return Matches.Update(ctx, exec, s, o)
}

// Delete deletes a single Match record with an executor
func (o *Match) Delete(ctx context.Context, exec bob.Executor) error {
	return Matches.Delete(ctx, exec, o)
}

// Reload refreshes the Match using the executor
func (o *Match) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Matches.Query(
		ctx, exec,
		SelectWhere.Matches.ID.EQ(o.ID),
	).One()
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

func (o MatchSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals MatchSetter) error {
	return Matches.Update(ctx, exec, &vals, o...)
}

func (o MatchSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	return Matches.Delete(ctx, exec, o...)
}

func (o MatchSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	IDPK := make([]uuid.UUID, len(o))

	for i, o := range o {
		IDPK[i] = o.ID
	}

	mods = append(mods,
		SelectWhere.Matches.ID.In(IDPK...),
	)

	o2, err := Matches.Query(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			*old = *new
			break
		}
	}

	return nil
}

func matchesJoinOpponent1Player[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Players.NameAs(ctx)).On(
			PlayerColumns.ID.EQ(MatchColumns.Opponent1ID),
		),
	}
}

func matchesJoinOpponent2Player[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Players.NameAs(ctx)).On(
			PlayerColumns.ID.EQ(MatchColumns.Opponent2ID),
		),
	}
}

func matchesJoinParentMatch1[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Matches.NameAs(ctx)).On(
			MatchColumns.ID.EQ(MatchColumns.ParentMatch1ID),
		),
	}
}

func matchesJoinReverseParentMatch1S[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Matches.NameAs(ctx)).On(
			MatchColumns.ParentMatch1ID.EQ(MatchColumns.ID),
		),
	}
}

func matchesJoinParentMatch2[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Matches.NameAs(ctx)).On(
			MatchColumns.ID.EQ(MatchColumns.ParentMatch2ID),
		),
	}
}

func matchesJoinReverseParentMatch2S[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Matches.NameAs(ctx)).On(
			MatchColumns.ParentMatch2ID.EQ(MatchColumns.ID),
		),
	}
}

func matchesJoinTournament[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Tournaments.NameAs(ctx)).On(
			TournamentColumns.ID.EQ(MatchColumns.TournamentID),
		),
	}
}

// Opponent1Player starts a query for related objects on player
func (o *Match) Opponent1Player(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) PlayersQuery {
	return Players.Query(ctx, exec, append(mods,
		sm.Where(PlayerColumns.ID.EQ(psql.Arg(o.Opponent1ID))),
	)...)
}

func (os MatchSlice) Opponent1Player(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) PlayersQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.Opponent1ID)
	}

	return Players.Query(ctx, exec, append(mods,
		sm.Where(psql.Group(PlayerColumns.ID).In(PKArgs...)),
	)...)
}

// Opponent2Player starts a query for related objects on player
func (o *Match) Opponent2Player(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) PlayersQuery {
	return Players.Query(ctx, exec, append(mods,
		sm.Where(PlayerColumns.ID.EQ(psql.Arg(o.Opponent2ID))),
	)...)
}

func (os MatchSlice) Opponent2Player(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) PlayersQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.Opponent2ID)
	}

	return Players.Query(ctx, exec, append(mods,
		sm.Where(psql.Group(PlayerColumns.ID).In(PKArgs...)),
	)...)
}

// ParentMatch1 starts a query for related objects on match
func (o *Match) ParentMatch1(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) MatchesQuery {
	return Matches.Query(ctx, exec, append(mods,
		sm.Where(MatchColumns.ID.EQ(psql.Arg(o.ParentMatch1ID))),
	)...)
}

func (os MatchSlice) ParentMatch1(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) MatchesQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.ParentMatch1ID)
	}

	return Matches.Query(ctx, exec, append(mods,
		sm.Where(psql.Group(MatchColumns.ID).In(PKArgs...)),
	)...)
}

// ReverseParentMatch1S starts a query for related objects on match
func (o *Match) ReverseParentMatch1S(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) MatchesQuery {
	return Matches.Query(ctx, exec, append(mods,
		sm.Where(MatchColumns.ParentMatch1ID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os MatchSlice) ReverseParentMatch1S(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) MatchesQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.ID)
	}

	return Matches.Query(ctx, exec, append(mods,
		sm.Where(psql.Group(MatchColumns.ParentMatch1ID).In(PKArgs...)),
	)...)
}

// ParentMatch2 starts a query for related objects on match
func (o *Match) ParentMatch2(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) MatchesQuery {
	return Matches.Query(ctx, exec, append(mods,
		sm.Where(MatchColumns.ID.EQ(psql.Arg(o.ParentMatch2ID))),
	)...)
}

func (os MatchSlice) ParentMatch2(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) MatchesQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.ParentMatch2ID)
	}

	return Matches.Query(ctx, exec, append(mods,
		sm.Where(psql.Group(MatchColumns.ID).In(PKArgs...)),
	)...)
}

// ReverseParentMatch2S starts a query for related objects on match
func (o *Match) ReverseParentMatch2S(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) MatchesQuery {
	return Matches.Query(ctx, exec, append(mods,
		sm.Where(MatchColumns.ParentMatch2ID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os MatchSlice) ReverseParentMatch2S(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) MatchesQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.ID)
	}

	return Matches.Query(ctx, exec, append(mods,
		sm.Where(psql.Group(MatchColumns.ParentMatch2ID).In(PKArgs...)),
	)...)
}

// Tournament starts a query for related objects on tournament
func (o *Match) Tournament(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TournamentsQuery {
	return Tournaments.Query(ctx, exec, append(mods,
		sm.Where(TournamentColumns.ID.EQ(psql.Arg(o.TournamentID))),
	)...)
}

func (os MatchSlice) Tournament(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TournamentsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.TournamentID)
	}

	return Tournaments.Query(ctx, exec, append(mods,
		sm.Where(psql.Group(TournamentColumns.ID).In(PKArgs...)),
	)...)
}

func (o *Match) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Opponent1Player":
		rel, ok := retrieved.(*Player)
		if !ok {
			return fmt.Errorf("match cannot load %T as %q", retrieved, name)
		}

		o.R.Opponent1Player = rel

		if rel != nil {
			rel.R.Opponent1Matches = MatchSlice{o}
		}
		return nil
	case "Opponent2Player":
		rel, ok := retrieved.(*Player)
		if !ok {
			return fmt.Errorf("match cannot load %T as %q", retrieved, name)
		}

		o.R.Opponent2Player = rel

		if rel != nil {
			rel.R.Opponent2Matches = MatchSlice{o}
		}
		return nil
	case "ParentMatch1":
		rel, ok := retrieved.(*Match)
		if !ok {
			return fmt.Errorf("match cannot load %T as %q", retrieved, name)
		}

		o.R.ParentMatch1 = rel

		if rel != nil {
			rel.R.ParentMatch1 = o
		}
		return nil
	case "ReverseParentMatch1S":
		rels, ok := retrieved.(MatchSlice)
		if !ok {
			return fmt.Errorf("match cannot load %T as %q", retrieved, name)
		}

		o.R.ReverseParentMatch1S = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ReverseParentMatch1S = MatchSlice{o}
			}
		}
		return nil
	case "ParentMatch2":
		rel, ok := retrieved.(*Match)
		if !ok {
			return fmt.Errorf("match cannot load %T as %q", retrieved, name)
		}

		o.R.ParentMatch2 = rel

		if rel != nil {
			rel.R.ParentMatch2 = o
		}
		return nil
	case "ReverseParentMatch2S":
		rels, ok := retrieved.(MatchSlice)
		if !ok {
			return fmt.Errorf("match cannot load %T as %q", retrieved, name)
		}

		o.R.ReverseParentMatch2S = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ReverseParentMatch2S = MatchSlice{o}
			}
		}
		return nil
	case "Tournament":
		rel, ok := retrieved.(*Tournament)
		if !ok {
			return fmt.Errorf("match cannot load %T as %q", retrieved, name)
		}

		o.R.Tournament = rel

		if rel != nil {
			rel.R.Matches = MatchSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("match has no relationship %q", name)
	}
}

func PreloadMatchOpponent1Player(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Player, PlayerSlice](orm.Relationship{
		Name: "Opponent1Player",
		Sides: []orm.RelSide{
			{
				From: "match",
				To:   TableNames.Players,
				ToExpr: func(ctx context.Context) bob.Expression {
					return Players.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Matches.Opponent1ID,
				},
				ToColumns: []string{
					ColumnNames.Players.ID,
				},
			},
		},
	}, Players.Columns().Names(), opts...)
}

func ThenLoadMatchOpponent1Player(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadMatchOpponent1Player(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load MatchOpponent1Player", retrieved)
		}

		err := loader.LoadMatchOpponent1Player(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadMatchOpponent1Player loads the match's Opponent1Player into the .R struct
func (o *Match) LoadMatchOpponent1Player(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Opponent1Player = nil

	related, err := o.Opponent1Player(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	related.R.Opponent1Matches = MatchSlice{o}

	o.R.Opponent1Player = related
	return nil
}

// LoadMatchOpponent1Player loads the match's Opponent1Player into the .R struct
func (os MatchSlice) LoadMatchOpponent1Player(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	players, err := os.Opponent1Player(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range players {
			if o.Opponent1ID.GetOrZero() != rel.ID {
				continue
			}

			rel.R.Opponent1Matches = append(rel.R.Opponent1Matches, o)

			o.R.Opponent1Player = rel
			break
		}
	}

	return nil
}

func PreloadMatchOpponent2Player(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Player, PlayerSlice](orm.Relationship{
		Name: "Opponent2Player",
		Sides: []orm.RelSide{
			{
				From: "match",
				To:   TableNames.Players,
				ToExpr: func(ctx context.Context) bob.Expression {
					return Players.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Matches.Opponent2ID,
				},
				ToColumns: []string{
					ColumnNames.Players.ID,
				},
			},
		},
	}, Players.Columns().Names(), opts...)
}

func ThenLoadMatchOpponent2Player(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadMatchOpponent2Player(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load MatchOpponent2Player", retrieved)
		}

		err := loader.LoadMatchOpponent2Player(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadMatchOpponent2Player loads the match's Opponent2Player into the .R struct
func (o *Match) LoadMatchOpponent2Player(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Opponent2Player = nil

	related, err := o.Opponent2Player(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	related.R.Opponent2Matches = MatchSlice{o}

	o.R.Opponent2Player = related
	return nil
}

// LoadMatchOpponent2Player loads the match's Opponent2Player into the .R struct
func (os MatchSlice) LoadMatchOpponent2Player(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	players, err := os.Opponent2Player(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range players {
			if o.Opponent2ID.GetOrZero() != rel.ID {
				continue
			}

			rel.R.Opponent2Matches = append(rel.R.Opponent2Matches, o)

			o.R.Opponent2Player = rel
			break
		}
	}

	return nil
}

func PreloadMatchParentMatch1(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Match, MatchSlice](orm.Relationship{
		Name: "ParentMatch1",
		Sides: []orm.RelSide{
			{
				From: "match",
				To:   TableNames.Matches,
				ToExpr: func(ctx context.Context) bob.Expression {
					return Matches.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Matches.ParentMatch1ID,
				},
				ToColumns: []string{
					ColumnNames.Matches.ID,
				},
			},
		},
	}, Matches.Columns().Names(), opts...)
}

func ThenLoadMatchParentMatch1(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadMatchParentMatch1(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load MatchParentMatch1", retrieved)
		}

		err := loader.LoadMatchParentMatch1(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadMatchParentMatch1 loads the match's ParentMatch1 into the .R struct
func (o *Match) LoadMatchParentMatch1(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ParentMatch1 = nil

	related, err := o.ParentMatch1(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	related.R.ParentMatch1 = o

	o.R.ParentMatch1 = related
	return nil
}

// LoadMatchParentMatch1 loads the match's ParentMatch1 into the .R struct
func (os MatchSlice) LoadMatchParentMatch1(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	matches, err := os.ParentMatch1(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range matches {
			if o.ParentMatch1ID.GetOrZero() != rel.ID {
				continue
			}

			rel.R.ParentMatch1 = o

			o.R.ParentMatch1 = rel
			break
		}
	}

	return nil
}

func ThenLoadMatchReverseParentMatch1S(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadMatchReverseParentMatch1S(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load MatchReverseParentMatch1S", retrieved)
		}

		err := loader.LoadMatchReverseParentMatch1S(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadMatchReverseParentMatch1S loads the match's ReverseParentMatch1S into the .R struct
func (o *Match) LoadMatchReverseParentMatch1S(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ReverseParentMatch1S = nil

	related, err := o.ReverseParentMatch1S(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ReverseParentMatch1S = MatchSlice{o}
	}

	o.R.ReverseParentMatch1S = related
	return nil
}

// LoadMatchReverseParentMatch1S loads the match's ReverseParentMatch1S into the .R struct
func (os MatchSlice) LoadMatchReverseParentMatch1S(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	matches, err := os.ReverseParentMatch1S(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ReverseParentMatch1S = nil
	}

	for _, o := range os {
		for _, rel := range matches {
			if o.ID != rel.ParentMatch1ID.GetOrZero() {
				continue
			}

			rel.R.ReverseParentMatch1S = append(rel.R.ReverseParentMatch1S, o)

			o.R.ReverseParentMatch1S = append(o.R.ReverseParentMatch1S, rel)
		}
	}

	return nil
}

func PreloadMatchParentMatch2(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Match, MatchSlice](orm.Relationship{
		Name: "ParentMatch2",
		Sides: []orm.RelSide{
			{
				From: "match",
				To:   TableNames.Matches,
				ToExpr: func(ctx context.Context) bob.Expression {
					return Matches.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Matches.ParentMatch2ID,
				},
				ToColumns: []string{
					ColumnNames.Matches.ID,
				},
			},
		},
	}, Matches.Columns().Names(), opts...)
}

func ThenLoadMatchParentMatch2(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadMatchParentMatch2(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load MatchParentMatch2", retrieved)
		}

		err := loader.LoadMatchParentMatch2(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadMatchParentMatch2 loads the match's ParentMatch2 into the .R struct
func (o *Match) LoadMatchParentMatch2(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ParentMatch2 = nil

	related, err := o.ParentMatch2(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	related.R.ParentMatch2 = o

	o.R.ParentMatch2 = related
	return nil
}

// LoadMatchParentMatch2 loads the match's ParentMatch2 into the .R struct
func (os MatchSlice) LoadMatchParentMatch2(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	matches, err := os.ParentMatch2(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range matches {
			if o.ParentMatch2ID.GetOrZero() != rel.ID {
				continue
			}

			rel.R.ParentMatch2 = o

			o.R.ParentMatch2 = rel
			break
		}
	}

	return nil
}

func ThenLoadMatchReverseParentMatch2S(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadMatchReverseParentMatch2S(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load MatchReverseParentMatch2S", retrieved)
		}

		err := loader.LoadMatchReverseParentMatch2S(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadMatchReverseParentMatch2S loads the match's ReverseParentMatch2S into the .R struct
func (o *Match) LoadMatchReverseParentMatch2S(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ReverseParentMatch2S = nil

	related, err := o.ReverseParentMatch2S(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ReverseParentMatch2S = MatchSlice{o}
	}

	o.R.ReverseParentMatch2S = related
	return nil
}

// LoadMatchReverseParentMatch2S loads the match's ReverseParentMatch2S into the .R struct
func (os MatchSlice) LoadMatchReverseParentMatch2S(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	matches, err := os.ReverseParentMatch2S(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ReverseParentMatch2S = nil
	}

	for _, o := range os {
		for _, rel := range matches {
			if o.ID != rel.ParentMatch2ID.GetOrZero() {
				continue
			}

			rel.R.ReverseParentMatch2S = append(rel.R.ReverseParentMatch2S, o)

			o.R.ReverseParentMatch2S = append(o.R.ReverseParentMatch2S, rel)
		}
	}

	return nil
}

func PreloadMatchTournament(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Tournament, TournamentSlice](orm.Relationship{
		Name: "Tournament",
		Sides: []orm.RelSide{
			{
				From: "match",
				To:   TableNames.Tournaments,
				ToExpr: func(ctx context.Context) bob.Expression {
					return Tournaments.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Matches.TournamentID,
				},
				ToColumns: []string{
					ColumnNames.Tournaments.ID,
				},
			},
		},
	}, Tournaments.Columns().Names(), opts...)
}

func ThenLoadMatchTournament(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadMatchTournament(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load MatchTournament", retrieved)
		}

		err := loader.LoadMatchTournament(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadMatchTournament loads the match's Tournament into the .R struct
func (o *Match) LoadMatchTournament(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Tournament = nil

	related, err := o.Tournament(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	related.R.Matches = MatchSlice{o}

	o.R.Tournament = related
	return nil
}

// LoadMatchTournament loads the match's Tournament into the .R struct
func (os MatchSlice) LoadMatchTournament(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	tournaments, err := os.Tournament(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range tournaments {
			if o.TournamentID != rel.ID {
				continue
			}

			rel.R.Matches = append(rel.R.Matches, o)

			o.R.Tournament = rel
			break
		}
	}

	return nil
}

func attachMatchOpponent1Player0(ctx context.Context, exec bob.Executor, count int, match0 *Match, player1 *Player) (*Match, error) {
	setter := &MatchSetter{
		Opponent1ID: omitnull.From(player1.ID),
	}

	err := Matches.Update(ctx, exec, setter, match0)
	if err != nil {
		return nil, fmt.Errorf("attachMatchOpponent1Player0: %w", err)
	}

	return match0, nil
}

func (match0 *Match) InsertOpponent1Player(ctx context.Context, exec bob.Executor, related *PlayerSetter) error {
	player1, err := Players.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachMatchOpponent1Player0(ctx, exec, 1, match0, player1)
	if err != nil {
		return err
	}

	match0.R.Opponent1Player = player1

	player1.R.Opponent1Matches = append(player1.R.Opponent1Matches, match0)

	return nil
}

func (match0 *Match) AttachOpponent1Player(ctx context.Context, exec bob.Executor, player1 *Player) error {
	var err error

	_, err = attachMatchOpponent1Player0(ctx, exec, 1, match0, player1)
	if err != nil {
		return err
	}

	match0.R.Opponent1Player = player1

	player1.R.Opponent1Matches = append(player1.R.Opponent1Matches, match0)

	return nil
}

func attachMatchOpponent2Player0(ctx context.Context, exec bob.Executor, count int, match0 *Match, player1 *Player) (*Match, error) {
	setter := &MatchSetter{
		Opponent2ID: omitnull.From(player1.ID),
	}

	err := Matches.Update(ctx, exec, setter, match0)
	if err != nil {
		return nil, fmt.Errorf("attachMatchOpponent2Player0: %w", err)
	}

	return match0, nil
}

func (match0 *Match) InsertOpponent2Player(ctx context.Context, exec bob.Executor, related *PlayerSetter) error {
	player1, err := Players.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachMatchOpponent2Player0(ctx, exec, 1, match0, player1)
	if err != nil {
		return err
	}

	match0.R.Opponent2Player = player1

	player1.R.Opponent2Matches = append(player1.R.Opponent2Matches, match0)

	return nil
}

func (match0 *Match) AttachOpponent2Player(ctx context.Context, exec bob.Executor, player1 *Player) error {
	var err error

	_, err = attachMatchOpponent2Player0(ctx, exec, 1, match0, player1)
	if err != nil {
		return err
	}

	match0.R.Opponent2Player = player1

	player1.R.Opponent2Matches = append(player1.R.Opponent2Matches, match0)

	return nil
}

func attachMatchParentMatch10(ctx context.Context, exec bob.Executor, count int, match0 *Match, match1 *Match) (*Match, error) {
	setter := &MatchSetter{
		ParentMatch1ID: omitnull.From(match1.ID),
	}

	err := Matches.Update(ctx, exec, setter, match0)
	if err != nil {
		return nil, fmt.Errorf("attachMatchParentMatch10: %w", err)
	}

	return match0, nil
}

func (match0 *Match) InsertParentMatch1(ctx context.Context, exec bob.Executor, related *MatchSetter) error {
	match1, err := Matches.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachMatchParentMatch10(ctx, exec, 1, match0, match1)
	if err != nil {
		return err
	}

	match0.R.ParentMatch1 = match1

	match1.R.ParentMatch1 = match0

	return nil
}

func (match0 *Match) AttachParentMatch1(ctx context.Context, exec bob.Executor, match1 *Match) error {
	var err error

	_, err = attachMatchParentMatch10(ctx, exec, 1, match0, match1)
	if err != nil {
		return err
	}

	match0.R.ParentMatch1 = match1

	match1.R.ParentMatch1 = match0

	return nil
}

func insertMatchReverseParentMatch1S0(ctx context.Context, exec bob.Executor, matches1 []*MatchSetter, match0 *Match) (MatchSlice, error) {
	for i := range matches1 {
		matches1[i].ParentMatch1ID = omitnull.From(match0.ID)
	}

	ret, err := Matches.InsertMany(ctx, exec, matches1...)
	if err != nil {
		return ret, fmt.Errorf("insertMatchReverseParentMatch1S0: %w", err)
	}

	return ret, nil
}

func attachMatchReverseParentMatch1S0(ctx context.Context, exec bob.Executor, count int, matches1 MatchSlice, match0 *Match) (MatchSlice, error) {
	setter := &MatchSetter{
		ParentMatch1ID: omitnull.From(match0.ID),
	}

	err := Matches.Update(ctx, exec, setter, matches1...)
	if err != nil {
		return nil, fmt.Errorf("attachMatchReverseParentMatch1S0: %w", err)
	}

	return matches1, nil
}

func (match0 *Match) InsertReverseParentMatch1S(ctx context.Context, exec bob.Executor, related ...*MatchSetter) error {
	if len(related) == 0 {
		return nil
	}

	matches1, err := insertMatchReverseParentMatch1S0(ctx, exec, related, match0)
	if err != nil {
		return err
	}

	match0.R.ReverseParentMatch1S = append(match0.R.ReverseParentMatch1S, matches1...)

	for _, rel := range matches1 {
		rel.R.ReverseParentMatch1S = append(rel.R.ReverseParentMatch1S, match0)
	}
	return nil
}

func (match0 *Match) AttachReverseParentMatch1S(ctx context.Context, exec bob.Executor, related ...*Match) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	matches1 := MatchSlice(related)

	_, err = attachMatchReverseParentMatch1S0(ctx, exec, len(related), matches1, match0)
	if err != nil {
		return err
	}

	match0.R.ReverseParentMatch1S = append(match0.R.ReverseParentMatch1S, matches1...)

	for _, rel := range related {
		rel.R.ReverseParentMatch1S = append(rel.R.ReverseParentMatch1S, match0)
	}

	return nil
}

func attachMatchParentMatch20(ctx context.Context, exec bob.Executor, count int, match0 *Match, match1 *Match) (*Match, error) {
	setter := &MatchSetter{
		ParentMatch2ID: omitnull.From(match1.ID),
	}

	err := Matches.Update(ctx, exec, setter, match0)
	if err != nil {
		return nil, fmt.Errorf("attachMatchParentMatch20: %w", err)
	}

	return match0, nil
}

func (match0 *Match) InsertParentMatch2(ctx context.Context, exec bob.Executor, related *MatchSetter) error {
	match1, err := Matches.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachMatchParentMatch20(ctx, exec, 1, match0, match1)
	if err != nil {
		return err
	}

	match0.R.ParentMatch2 = match1

	match1.R.ParentMatch2 = match0

	return nil
}

func (match0 *Match) AttachParentMatch2(ctx context.Context, exec bob.Executor, match1 *Match) error {
	var err error

	_, err = attachMatchParentMatch20(ctx, exec, 1, match0, match1)
	if err != nil {
		return err
	}

	match0.R.ParentMatch2 = match1

	match1.R.ParentMatch2 = match0

	return nil
}

func insertMatchReverseParentMatch2S0(ctx context.Context, exec bob.Executor, matches1 []*MatchSetter, match0 *Match) (MatchSlice, error) {
	for i := range matches1 {
		matches1[i].ParentMatch2ID = omitnull.From(match0.ID)
	}

	ret, err := Matches.InsertMany(ctx, exec, matches1...)
	if err != nil {
		return ret, fmt.Errorf("insertMatchReverseParentMatch2S0: %w", err)
	}

	return ret, nil
}

func attachMatchReverseParentMatch2S0(ctx context.Context, exec bob.Executor, count int, matches1 MatchSlice, match0 *Match) (MatchSlice, error) {
	setter := &MatchSetter{
		ParentMatch2ID: omitnull.From(match0.ID),
	}

	err := Matches.Update(ctx, exec, setter, matches1...)
	if err != nil {
		return nil, fmt.Errorf("attachMatchReverseParentMatch2S0: %w", err)
	}

	return matches1, nil
}

func (match0 *Match) InsertReverseParentMatch2S(ctx context.Context, exec bob.Executor, related ...*MatchSetter) error {
	if len(related) == 0 {
		return nil
	}

	matches1, err := insertMatchReverseParentMatch2S0(ctx, exec, related, match0)
	if err != nil {
		return err
	}

	match0.R.ReverseParentMatch2S = append(match0.R.ReverseParentMatch2S, matches1...)

	for _, rel := range matches1 {
		rel.R.ReverseParentMatch2S = append(rel.R.ReverseParentMatch2S, match0)
	}
	return nil
}

func (match0 *Match) AttachReverseParentMatch2S(ctx context.Context, exec bob.Executor, related ...*Match) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	matches1 := MatchSlice(related)

	_, err = attachMatchReverseParentMatch2S0(ctx, exec, len(related), matches1, match0)
	if err != nil {
		return err
	}

	match0.R.ReverseParentMatch2S = append(match0.R.ReverseParentMatch2S, matches1...)

	for _, rel := range related {
		rel.R.ReverseParentMatch2S = append(rel.R.ReverseParentMatch2S, match0)
	}

	return nil
}

func attachMatchTournament0(ctx context.Context, exec bob.Executor, count int, match0 *Match, tournament1 *Tournament) (*Match, error) {
	setter := &MatchSetter{
		TournamentID: omit.From(tournament1.ID),
	}

	err := Matches.Update(ctx, exec, setter, match0)
	if err != nil {
		return nil, fmt.Errorf("attachMatchTournament0: %w", err)
	}

	return match0, nil
}

func (match0 *Match) InsertTournament(ctx context.Context, exec bob.Executor, related *TournamentSetter) error {
	tournament1, err := Tournaments.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachMatchTournament0(ctx, exec, 1, match0, tournament1)
	if err != nil {
		return err
	}

	match0.R.Tournament = tournament1

	tournament1.R.Matches = append(tournament1.R.Matches, match0)

	return nil
}

func (match0 *Match) AttachTournament(ctx context.Context, exec bob.Executor, tournament1 *Tournament) error {
	var err error

	_, err = attachMatchTournament0(ctx, exec, 1, match0, tournament1)
	if err != nil {
		return err
	}

	match0.R.Tournament = tournament1

	tournament1.R.Matches = append(tournament1.R.Matches, match0)

	return nil
}
